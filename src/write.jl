
export write_dataframe 
function write_dataframe(;settings,bucket,measurement,data,fields,timestamp,tags=String[],batchsize::Int = 0,influx_precision::String = "ns",tzstr::String = "UTC",compress::Bool=false,printinfo::Bool=true)
    size(data,1) < 1 && throw(ArgumentError("DataFrame has zero rows"))
    #for some cases (size(data,1)==1) we do not perform batch processing
    if (batchsize <= 0) || (size(data,1) <= batchsize) || (size(data,1) == 1)
        lp = lineprotocol(measurement,data,fields,timestamp,tags=tags,influx_precision=influx_precision,tzstr=tzstr,compress=compress)
        rs = write_data(settings,bucket,lp,"ns")
    else 
        i = 0
        sz = size(data,1)
        endpos = 1 
        startpos = 1
        nbatches = trunc(Int,ceil(sz/batchsize))
        while endpos < sz
            i += 1
            #loop over batches
            printinfo && @info("Processing batch $(i) of $(nbatches)...")
            endpos = min(sz,startpos + batchsize - 1)
            vdata = view(data,startpos:endpos,:)
            lp = lineprotocol(measurement,vdata,fields,timestamp,tags=tags,influx_precision=influx_precision,tzstr=tzstr,compress=compress)
            rs = write_data(settings,bucket,lp,"ns")
            startpos = endpos + 1            
        end        
    end
    
    #@show batchsize 
    #@show length(lp)
    #note this is the RS,LP of the LAST batch, if processing in batches was enabled
    return rs,lp
end

export write_data
function write_data(isettings,bucket::String,payload::Union{String,Vector{UInt8}},influx_precision::String;compress::Bool=false)
    #= 
    influx_precision = "ns"
    bucket = a_random_bucket_name
    create_bucket(isettings,bucket);
    payload = """myMeasurement,tag1=value1,tag2=value2 fieldKey="fieldValue" 1556813561098000000"""

    payload = """airSensors,sensor_id=TLM0201 temperature=73.97038159354763,humidity=35.23103248356096,co=0.48445310567793615 1630424257000000000
                airSensors,sensor_id=TLM0202 temperature=75.30007505999716,humidity=35.651929918691714,co=0.5141876544505826 1630424257000000000
                airSensors,sensor_id=TLM0202 temperature=70.30007505999716,humidity=45.651929918691714,co=0.7141876544505826 1630424258000000000
                airSensors,sensor_id=TLM0202 temperature=72.30007505999716,humidity=30.651929918691714,co=0.6141876544505826 1630424259000000000"""
    =#

    @unpack INFLUXDB_HOST,INFLUXDB_TOKEN,INFLUXDB_ORG = isettings
        
    if !bucket_exists(isettings,bucket)
        throw(ArgumentError("Bucket $bucket does  not exist"))
    end

    if !in(influx_precision,PRECISIONS)
        throw(ArgumentError("Invalid influx_precision: $(influx_precision) is not an element of $PRECISIONS"))
    end

    #should we validate the payload, i.e. whether it is valid LP syntax
    #I think rather not, as it will generally be generated by this very package (and thus be valid)

    #buckets,_ = get_buckets(isettings;limit=100,offset=0)
    
    #To send a line protocol payload, pass Content-Type: text/plain; charset=utf-8.    
    hdrs = Dict("Authorization" => "Token $(INFLUXDB_TOKEN)", "Accept"=>"application/json","Content-Type"=>"application/json; charset=utf-8")
    url = """http://$(INFLUXDB_HOST)/api/v2/write?org=$INFLUXDB_ORG&bucket=$bucket&precision=$influx_precision"""
    #@show typeof(payload)
    if compress
        #gzip
        hdrs["Content-Encoding"] = "gzip"
        bdy = CodecZlib.transcode(CodecZlib.GzipCompressor, payload)
    else        
        if typeof(payload) == Vector{UInt8}
            hdrs["Content-Encoding"] = "gzip"
        else 
            hdrs["Content-Encoding"] = "identity"
        end        
        bdy = payload
    end

    r = HTTP.request("POST", url, hdrs, body = bdy)
    if !in(r.status,[204])
        @warn "Unexpected status" r.status String(r.body)
    end

    #=
        
    
    =#
    #content-length
    #The size of the entity-body, in bytes, sent to InfluxDB. If the length is greater than the max body configuration option, the server responds with status code 413.

    return r.status
end